# 机器人控制系统架构说明

## 概述

重构后的系统采用模块化架构，便于添加新功能和维护现有代码。当前系统专注于ArUco跟随功能，为后续扩展提供了良好的基础架构。

## 架构设计

### 核心组件

1. **RobotSystem** (main.py)
   - 系统主控制器
   - 负责模块管理和系统级操作
   - 处理模块切换和资源管理

2. **BaseModule** (utils/base_module.py)
   - 功能模块基类
   - 定义统一的模块接口
   - 提供键盘处理和状态管理

3. **功能模块** (modules/)
   - ArucoFollowModule: ArUco跟随功能（当前唯一活跃模块）

### 目录结构

```
├── main.py                 # 主程序入口
├── api/                    # API接口层
│   ├── camera_api.py      # 相机通信
│   └── robot_control_api.py # 机器人控制
├── utils/                 # 工具模块
│   ├── base_module.py     # 模块基类
│   ├── aruco_processor.py # ArUco处理
│   ├── coordinate_transforms.py # 坐标变换
│   └── robot_controller.py # 机器人控制器
├── modules/               # 功能模块
│   └── aruco_follow_module.py # ArUco跟随
└── config/               # 配置文件
    ├── camera_config.py  # 相机配置
    └── robot_config.py   # 机器人配置
```

## 使用方法

### 运行系统

```bash
python main.py
```

### 系统控制

- **Q**: 退出系统
- **WASD**: 相机控制（所有模块通用）
- **X**: 相机复位

### ArUco跟随模块控制

- **M/N**: 启用/禁用跟随模式
- **IJKLRT**: 位置调整
- **UOYPGH**: 角度调整
- **ZCV**: 预设配置

## 添加新功能模块

### 1. 创建模块类

```python
from utils.base_module import BaseModule

class YourModule(BaseModule):
    def __init__(self, robot_controller, aruco_processor=None):
        super().__init__("Your Module Name", robot_controller, aruco_processor)
        self.key_bindings = self.get_key_bindings()
    
    def process_frame(self, frame):
        # 处理图像帧的逻辑
        return frame
    
    def get_key_bindings(self):
        # 返回键盘映射字典
        return {
            ord('your_key'): self.your_function,
        }
```

### 2. 注册模块

在 `main.py` 的 `_initialize_modules()` 方法中添加：

```python
self.modules["your_module"] = YourModule(self.robot_controller, self.aruco_processor)
```

### 3. 添加切换按键（可选）

如果需要运行时切换模块，可以在 `_setup_system_key_handlers()` 中添加：

```python
ord('2'): lambda: self._switch_module("your_module"),
```

## 扩展指南

### 模块开发最佳实践

1. **继承BaseModule**: 所有功能模块都应继承BaseModule
2. **实现必要方法**: process_frame() 和 get_key_bindings()
3. **状态管理**: 使用activate()和deactivate()管理模块状态
4. **资源清理**: 在cleanup()中释放资源
5. **错误处理**: 添加适当的异常处理

### 键盘映射规范

- **系统级**: Q退出，数字键可用于模块切换（如需要）
- **通用功能**: WASD相机控制，X复位
- **模块特定**: 使用字母键实现模块功能
- **避免冲突**: 检查现有映射，避免按键冲突

### 状态显示

- 使用draw_status()在图像上显示模块状态
- 提供清晰的控制提示
- 显示当前操作状态和参数

## 优势

1. **模块化**: 功能独立，易于开发和维护
2. **可扩展**: 轻松添加新功能模块
3. **统一接口**: 所有模块遵循相同的接口规范
4. **资源管理**: 自动处理模块切换和资源清理
5. **键盘管理**: 统一的键盘处理机制
6. **状态隔离**: 模块间状态独立，避免相互影响

这种架构使得系统更加灵活和可维护，为后续功能扩展提供了良好的基础。